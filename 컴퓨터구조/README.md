# <span style = color:yellow> 컴퓨터 구조 요약 정리 </span>

### 01. 컴퓨터 구조 소개
***
>1.1 컴퓨터 구조 범위
- 컴퓨터
  - 계산하는 기계
  - 프로그램 실행하는 기계
- 프로그램
  - 명령어의 나열
- 명령어
  - 프로그래머가 실행 지시할 수 있는 최소 작업 단위
- 계층으로 본 컴퓨터
  - 고급언어 프로그램<br>어셈블리 프로그램<br>프로그래머 모델(프로세서 구조, 명령어 집합)<br>컴퓨터 조직(CPU, Memory, etc)<br>논리회로<br>반도체 기술
- 위쪽으로 갈 수록 사람 친화적, 아래쪽은 물리(기계) 친화적
- 반도체 구실과 논리회로
  - 반도체 기술
    - 전자적으로 동작하는 스위칭 소자 제공
    - 컴퓨터의 기본 소자인 논리 게이트 구현
  - 논리 회로 
    - 물리 개념 -> 논리 개념으로 분리
    - 부울 대수로 표현
    - 논리 게이트 : 논리 회로 동작을 표현
- 컴퓨터 구성 요소
  - 중앙처리장치, 기억장치, 입출력 장치
  - 시스템 버스(위 장치들을 연결)
- 프로그래머 모델
  - 컴퓨터 조직 중에서 프로그램을 작성할 수 있도록 제공되는 부분
  - ex) 명령어 집합, 레지스터 구조, 기억장치 구조
- 명령어 집합
  - 명령어들의 모임
  - HW - SW 연결 (인터페이스의 역할)
  - 명령어 
    - 기본적인 작업 단위
- 소프트웨어 계층
  - 어셈블리 프로그램 
    - 기계 의존적
    - 시스템 프로그램 개발에 특화
  - 고급언어 프로그램
    - 기계 독립적
    - 응용 프로그램 개발에 특화
  - 시스템 프로그램
    - ex) 운영체제, 컴파일러, 파일 탐색기
  - 응용 프로그램
    - 일반적으로 사용하는 SW정도로 이해
>1.2 컴퓨터 구성 요소
- 폰 노이만이 제안한 프로그램 내장형 구조
- 구성 요소 기능
  - 중앙 처리 장치
    - 제어 및 연산
  - 기억장치
    - 프로그램과 데이터를 저장
  - 입출력장치
    - 컴퓨터의 내부와 외부 연결
  - 시스템 버스
    - 컴퓨터 구성 요소 간 데이터 전달 경로
    - 중앙 처리 장치 <-> 입출력 장치 <-> 기억장치
>1.3 컴퓨터의 발달 과정
- 세대별 컴퓨터 분류
  - 기계식: 산술계산용
  - 1세대 진공관 : 전자식 컴퓨터의 시작, 에니악
    - 폰 노이만이 1945년 내장형 프로그램 방식 컴퓨터 구조 제안, 전자식 컴퓨터 방식 제안
  - 2세대 트랜지스터 : 자기 코어 기억장치, 초기 고급 언어 도입
    - 개폐, 흐름제어와 같은 스위칭 기능 수행
  - 3세대 집적회로 : 반도체 기억장치, 운영체제
    - 집적회로(모으고 쌓는것, Performance 상승)
  - 4세대 대규모집적회로(VLSI) : 마이크로프로세서 
    - (명령이 많이 필요없는 장치에, 안전성, 신뢰성이 요구되는 장치에 사용)
  - 무어의 법칙 : 반도체 집적회로의 성능이 18개월마다 2배로 증가한다.
- 마이크로프로세서 이후
  - 1980년대 중반까지 (처리 용량이 개선)
    - 반도체 집적 기술 발달
    - 계열(family)개념을 바탕으로 발전, 처리용량 높임
    - 상향 호환성(상위호환) 유지
  - 1980년대 중반 이후 (프로세서 내부 조직 개선)
    - 캐시 기억장치 도입, 가상기억 장치 도입, 명령어를 동시에 처리하는 파이프라인 기법 도입
    - 결과로 RISC(Reduced Instruction Set Computer) 프로세서 개발
    - 한번에 여러 개의 명령어를 처리하는 슈퍼 스칼라 프로세서 개발
    - ex) ARM, Power PC, MIPS
  - 2000년대 이후 : 멀티 코어 프로세서 등장
***
### 02. 논리회로 기초
***
>2.1 수와 코드
- 수의 체계
- R 진수
- 진법 변환
  - R진수 -> 10진수
  - 10진수 -> R진수
    - 진법이 변해도 값은 그대로
    - 10진수 값을 R로 나누고 나머지를 X<small>i</small> (i = 0 ~ n)로 몫을 다시 R로 나누는 과정 반복해 몫이 0이 될때까지
  - 진법 변환하는 방법 명확히 알기
  - 예제를 많이 풀어볼 것
- 2진수, 8진수, 16진수
  - 2진수
    - 사람이 다루기 불편
- 코드
  - 유한 개의 원소로 구성된 집합의 원소들에게<br>서로 구분할 수 있는 유일한 수를 부여한 숫자
- 숫자코드
  - 이진화십진코드 : 10진수 기호를 2진수로 표현
  - 3초과 코드 : 각 자리에 3을 더한 후 2진수로 표현
- 문자코드
  - ASCII, Unicode
  - 아스키 코드 표 보는 법 이해하기
>2.2 조합 논리 회로
- 논리 게이트
  - 이진 신호가 통과하는 문
  - 논리 게이트 그리는 법(게이트의 모양) 알아두기
  - ex) AND게이트, OR게이트, NOR게이트 등등 
- 정논리와 부논리
  - 정논리 : 신호 레벨이 high일 때 사건 발생
  - 부논리 : 신호 레벨이 low일 때 사건 발생
- 조합논리회로 표현
  - 표현 방법 (진리표, 논리식, 논리 회로도)
  - 궤환 경로(feedback path)가 없다. 한 방향이란 뜻
- 다수 함수
  - 세 개의 입력 신호 : X, Y, Z
  - 출력 : F
- 디코더
  - n비트의 입력을 최대 2^n개의 출력으로 변환하는 장치
- 인코더
  - m개의 입력에 대하여 n비트의 코드를 생성하는 장치
  - 이 때 입력신호가 두 개 이상 동시에 1이될 수 없다.
- 멀티플렉서와 디멀티플렉서
  - 멀티플렉서
    - 여러 개의 입력선 중에서 하나를 선택하여 출력으로 전달
  - 디멀티플렉서
    - 하나의 입력선 여러개의 출력
  - 동작 특성표
- 가산기
  - 반가산기
    - 두 개의 한 비트를 더하여 합과 자리올림수를 생성하는 회로
  - 전가산기
    - 이전단에서 전달된 자리올림수까지 같이 더하는 회로
>2.3 순차논리회로
- 순차논리회로의 구조
  - 기억 소자(flip-flop)를 포함한다
  - 출력 신호 = F(입력신호, 내부 상태)
- 동기 순차논리회로 (기억소자들이 모두 같은 시간에 동작)
- 플립플롭
  - 데이터 한 비트(2진)의 정보를 저장하는 기억 소자
  - 입력이 변하더라도 클럭이 변하지 않으면 출력은 그대로
  - 종류 : D, SR, JK, T
  - 동작시기
    - 이벤트 직전의 입력값에 따라 직후의 출력이 변함
    - Latch or Level Trigger (High상태로 유지될 때 동작)
    - Positive Edge Trigger (상승 Edge 순간에 동작)
    - Negative Edge Trigger (하강 Edge 순간에 동작)
  - 출력이 정상 출력(Q)와 부출력이다.
  - D Flip-Flop
    - 입력선이 D 하나
    - 클럭의 변화가 있어야 출력이 나타남 -> 입력값을 지연시키는 효과
  - SR Flip-Flop
    - 입력선이 S(Set)와 R(Reset) 두 개
  - JK Flip-Flop
  - T Flip-Flop
- 레지스터
  - 여러 비트의 이진 데이터를 저장하는 소자 클럭을 공유하여 동시에 동작
  - 레지스터가 주어졌을 때 레지스터의 입출력이 병렬인지 직렬인지 이해하기
  - 4비트 레지스터의 동작 해석 가능해야 함
- 시프트 레지스터
  - 데이터를 왼쪽 or 오른쪽으로 자리 이동하는 레지스터
- 카운터
  - 미리 정해진 순서로 상태를 변경하는 레지스터
  - 이진 카운터
>2.4 레지스터 전송 언어

***
### 03. 컴퓨터 구성 요소
***
>3.1 프로그램의 실행
- 고급언어 프로그램과 기계어 프로그램
  - 기계어
    - 2진수의 기계코드, 사람이 알아보기 힘듦
  - 어셈블리 언어와 어셈블러
- 프로그램 내장형 컴퓨터
  - 폰 노이만이 제안하였음
  - 프로그램과 데이터를 주기억장치에 저장
  - 명령어를 중앙처리장치로 가져와 실행
  - 기억장치 구조
    - 프로그램 내장형 컴퓨터 : 중앙처리장치와 주기억장치 간의 통신 채널이 1개
    - 하버드 구조 : 주기억장치를 프로그램 기억장치와 데이터 기억장치로 분리  
- 명령어 사이클
  - 중앙처리장치는 컴퓨터에 전원을 인가한 후 두 가지 단계를 무한히 반복함으로 프로그램을 실행한다.
  - 인출단계 (fetch stage)
    - 기억장치에서 명령어를 중앙처리장치로 가져온다.
  - 실행단계 (execution stage)
    - 중앙처리장치에서 명령어를 해독해 실행
>3.2 컴퓨터 구성 요소
- 중앙처리장치
  - 중앙처리장치는 명령어 사이클을 수행함으로 프로그램을 실행한다.
  - 인출 단계에서
    - 구성 요소
      - PC (Program Counter)
        - 다음에 실행할 명령어가 들어있는 기억장치 주소를 저장
      - IR (Instruction Register)
        - 현재 실행중인 명령어를 저장
    - 주기억장치 PC 번지에 있는 명령어를 IR에 저장 <br>이와 동시에 다음 명령어를 가리키도록 PC 값 증가
  - 실행 단계에서
    - 구성 요소
      - 제어장치
        - 명령어 해독
        - 제어신호 생성
      - 처리장치
        - 내부 레지스터
          - 데이터 임시 저장
        - 연산기
          - 산술연산, 논리연산
- 주기억장치
  - 구성
    - 주소선 : 기억장치에 대한 입력신호로 작용한다. n비트의 주소선으로 2^n개의 기억장소를 지정할 수 있다.
    - 데이터선 : 기억장치에 대한 입력과 출력신호로 작용한다. 1개의 기억장소에 k비트 데이터를 저장한다.
    - 읽기/쓰기 제어선 : 기억장치에 대한 입력신호
  - 기억장치 액세스 방법
    - 적재(load) : 기억장치의 한 장소(주소)에서 데이터를 읽어서 중앙처리장치의 레지스터로 가져온다.<br>Register <- Mem[Address]
    - 저장(store) : 중앙처리장치의 레지스터에서 기억장치 한 장소에 데이터를 저장한다.<br>Mem[Address] <- Register
- 입출력장치
  - 기능
    - 외부에서 데이터를 받아 처리
    - 결과를 외부로 제공
  - 특징
    - 기계 동작을 수반 하기 때문에
    - 전기 신호보다 동작 속도가 느리다
  - 구조
    - 인터페이스(interface)
    - 신호변환기(transducer)
    - 기계장치(actuator)
  - 연결에 사용되는 신호선
    - 주소선
    - 데이터선
    - 제어선
- AVR 마이크로제어기
  - 마이크로제어기
    - 하나의 칩안에 중앙처리장치, 기억장치, 주변장치를 포함한 반도체 소자
    - 소형 시스템의 제어장치로 쓰인다.
  - 구성 요소
    - 하버드 구조(기억장치가 프로그램 기억장치와 데이터 기억장치로 나뉨)
    - 프로그램을 플래시 프로그램 메모리에 저장. 비휘발성
    - 별도의 데이터 기억장치 포함. 휘발성
    - 명령어 레지스터는 제어장치로 명령어를 전달한다.
    - 8비트 상태 레지스터를 포함
    - 32개의 8비트 범용 레지스터를 포함. 이들은 프로그램이 처리하는 데이터를 임시로 저장한다.
    - 여러가지 주변장치(Peripherals)를 포함. 이들은 입출력장치
    - 이들은 시스템 버스로 연결되어있다.
>3.3 시스템 버스
- 시스템 버스 구성
  - 한 번에 한 개의 장치만 데이터를 전송할 수 있다.
  - 기능에 따라
    - 주소 버스
      - 기억장치 or 입출력장치의 주소를 지정
    - 데이터 버스
      - 데이터를 전달하는 경로이고, 데이터 버스 폭은 8의 배수.
      - 레지스터의 크기 = 단어 크기
    - 제어 버스
      - 주소 버스와 데이터 버스를 제외한 나머지 신호선을 모은 것
- 제어 신호 종류
  - 제어 버스에 속한 신호선은 종류마다 용도가 다르다.
  - 기억장치 읽기
  - 기억장치 쓰기
  - 입출력 읽기 
  - 입출력 쓰기 
  - 인터럽트 요청
  - 인터럽트 확인 
  - 버스 요청
  - 버스 승인
  - 시스템 클럭
  - 리셋
  - 전력선
  - Bus Busy
- 버스 계층
  - 시스템 버스에 연결된 장치가 많아질 수록 시스템 버스에 대한 경쟁이 심해지고,<br> 결과적으로 데이터 전송 속도가 느려지는 현상이 발생
  - 이를 해결하기 위해 버스를 계층으로 구성한다.
    - 브리지 : 두 개의 버스를 서로 연결, 중재 역할
    - 시스템 버스 : 지역 버스, 고속 버스
    - 입출력 버스 : 확장 버스, 저속 버스, 장치 버스
>3.4 명령어
- 명령어의 구성 요소
  - 명령어 : 컴퓨터가 해야할 일을 지시
  - 구성 요소
    - 동작 코드(opcode, operation code) : 연산 코드, 동작을 나타내는 부분
    - 동작의 대상(operand) : 피연산자
  - 명령어 형식
    - 명령어 구성요소를 2진수에 배치한 형태
- 명령어 종류
  - 동작 코드의 기능에 따라
    - 데이터 전달 명령어 : 단순히 데이터를 전달
      - 동작코드의 예
        - 적재(load) 메모리 -> 레지스터
        - 저장(store) 메모리 <- 레지스터
        - 이동(move) 레지스터 <-> 레지스터
        - 입력(input) I/O -> 레지스터
        - 출력(output) I/P <- 레지스터
    - 데이터 처리 명령어
      - 동작코드의 그룹별 예
        - 단항 연산 명령어 : 한 개의 항으로 계산을 수행하는 명령어
          - 목적지 = op 소스
          - Negate(음수, 부호 변경)
          - Not, Shift
          - 증가, 감소
        - 이항 연산 명령어 : 두 개의 항으로
          - 사칙 연산
          - 논리 연산
    - 프로그램 제어 명령어 : 명령어 실행 순서 변경(프로그램 카운터 값 변경)
      - 무조건 분기 : PC 값을 분기 목적지 주소로 변경, 항상 분기 목적지로 분기
      - 조건 분기 : if (조건) : 분기 목적지 주소로 이동
      - 서브루틴 호출 or 함수 호출 : 다음에 실행할 명령어 주소(PC)를 저장하고, PC에 서브루틴 시작 주소 적재
      - 서브루틴 복귀 : 호출하고나서 호출한 곳으로 돌아갈 때 저장해 두었던 주소로 복귀
- 오퍼랜드
  - 명령어가 처리하려는 동작의 대상
  - 유효 데이터
    - 명령어가 실제로 처리하는 데이터
    - 유효 데이터 저장장소 or 유효 데이터 그 자체
  - 유형
    - 즉치 데이터 : 실제 처리되는 값
    - 레지스터 이름 
    - 기억장치 주소
    - 입출력 포트
  - 해석 방법 (각 유효 데이터의 특징)
    - 부호 없는 수
    - 정수
    - 실수
    - 문자 코드
>3.5 명령어 실행 과정
- 프로그래머 모델
  - 프로그래머가 프로그램을 작성하기 위하여 알고 있어야 할 컴퓨터 구조
  - ToyCOM
    - 구성
      - 기억장치 : 주소 버스 8비트, 용량은 256 * 8비트 데이터 버스 8비트
      - 프로그램 카운터 : 기억장치의 주소를 저장해야 하므로 크기는 8비트
      - 명령어 레지스터 : 명령어의 크기 16비트 가정, 따라서 IR의 크기는 16비트
      - 레지스터 파일(R0~R15) : 8비트 데이터를 저장하는 16개의 레지스터, 한 개의 레지스터를 지정하는데 4비트 필요
      - 연산(ALU) : 레지스터에 대해서만 동작
    - 명령어 형식
      - 데이터 전달 명령어 : 동작코드 4비트, 레지스터 하나 지정하는 4비트, 기억장치 주소 지정하는 8비트로 구성
      - 데이터 처리 명령어 : 동작코드 4비트, 목적지 레지스터 4비트, 두 개의 소스 레지스터 각각 4비트 할당
    - 명령어 집합
      - 적재
      - 저장
      - 더하기
      - 빼기
      - AND
      - OR
- 프로그램 실행 과정
  - 명령어 사이클에 따라 프로그램을 실행
    - 인출 단계(fetch)
    - 